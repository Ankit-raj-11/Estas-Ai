id: security-scan-flow
namespace: company.team

description: Complete automated security scanning workflow with AI-powered fixes

inputs:
  - id: scanId
    type: STRING
    description: Unique scan identifier
  - id: repoUrl
    type: STRING
    description: GitHub repository URL
  - id: branch
    type: STRING
    description: Branch to scan
    defaults: main
  - id: backendUrl
    type: STRING
    description: Backend API URL for callbacks

variables:
  fixBranch: "security-fixes-{{execution.startDate | date('yyyyMMdd-HHmmss')}}"

tasks:
  # Step 1: Clone Repository, Run Scans, and Create Fix Branch
  - id: clone_scan_and_branch
    type: io.kestra.plugin.scripts.shell.Commands
    description: Clone repository, run security scans, and create fix branch
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: python:3.11-slim
    outputFiles:
      - "scan-results.json"
      - "branch-name.txt"
      - "fork-owner.txt"
    commands:
      - |
        echo "=== Security Scanner Starting ==="
        echo "Scan ID: {{inputs.scanId}}"
        echo "Repository: {{inputs.repoUrl}}"
        echo "Branch: {{inputs.branch}}"
        echo ""
        
        # Install required tools
        echo "Installing dependencies..."
        apt-get update -qq
        apt-get install -y -qq git curl jq > /dev/null 2>&1
        
        # Install Python security tools
        pip install --quiet bandit semgrep
        
        # Extract owner and repo from URL
        REPO_URL="{{inputs.repoUrl}}"
        OWNER=$(echo "$REPO_URL" | sed 's|https://github.com/||' | cut -d/ -f1)
        REPO=$(echo "$REPO_URL" | sed 's|https://github.com/||' | cut -d/ -f2)
        
        echo "Target Repository: $OWNER/$REPO"
        
        # Check if we have write access, if not, fork it
        echo "Checking repository access..."
        REPO_CHECK=$(curl -s -H "Authorization: token {{secret('GITHUB_TOKEN')}}" \
          "https://api.github.com/repos/$OWNER/$REPO")
        
        CAN_PUSH=$(echo "$REPO_CHECK" | jq -r '.permissions.push // false')
        
        if [ "$CAN_PUSH" != "true" ]; then
          echo "No write access to $OWNER/$REPO, forking repository..."
          
          # Get authenticated user first
          MY_USER=$(curl -s -H "Authorization: token {{secret('GITHUB_TOKEN')}}" \
            "https://api.github.com/user" | jq -r '.login')
          
          echo "Authenticated as: $MY_USER"
          
          # Fork the repository
          FORK_RESPONSE=$(curl -s -X POST \
            -H "Authorization: token {{secret('GITHUB_TOKEN')}}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$OWNER/$REPO/forks")
          
          echo "Forked to: $MY_USER/$REPO"
          echo "Waiting for fork to be ready..."
          sleep 10
          
          # Clone from fork
          CLONE_URL="https://{{secret('GITHUB_TOKEN')}}@github.com/$MY_USER/$REPO.git"
          FORK_OWNER="$MY_USER"
        else
          echo "Have write access to $OWNER/$REPO, cloning directly..."
          CLONE_URL="https://{{secret('GITHUB_TOKEN')}}@github.com/$OWNER/$REPO.git"
          FORK_OWNER="$OWNER"
        fi
        
        # Clone repository
        echo "Cloning repository..."
        git clone -b {{inputs.branch}} "$CLONE_URL" repo || {
          echo "Failed to clone repository"
          exit 1
        }
        
        # Save fork owner for later use
        echo "$FORK_OWNER" > fork-owner.txt
        
        cd repo
        echo "Repository cloned successfully!"
        echo ""
        
        # Run Semgrep
        echo "Running Semgrep security scanner..."
        semgrep --config auto --json --quiet . > ../semgrep-raw.json 2>/dev/null || echo "Semgrep completed"
        
        # Run Bandit (Python)
        echo "Running Bandit for Python files..."
        bandit -r . -f json -o ../bandit-raw.json 2>/dev/null || echo "Bandit completed"
        
        # Parse and aggregate results
        cd ..
        echo "Aggregating scan results..."
        
        python3 << 'PYTHON_SCRIPT'
        import json
        import os
        
        findings = []
        
        # Parse Semgrep results
        if os.path.exists('semgrep-raw.json'):
            try:
                with open('semgrep-raw.json', 'r') as f:
                    semgrep_data = json.load(f)
                    if 'results' in semgrep_data:
                        for result in semgrep_data['results'][:10]:
                            findings.append({
                                'tool': 'semgrep',
                                'file': result.get('path', 'unknown'),
                                'line': result.get('start', {}).get('line', 0),
                                'severity': result.get('extra', {}).get('severity', 'medium'),
                                'rule': result.get('check_id', 'unknown'),
                                'message': result.get('extra', {}).get('message', 'Security issue detected')
                            })
                        print(f"Found {len(findings)} Semgrep issues")
            except Exception as e:
                print(f"Error parsing Semgrep: {e}")
        
        # Parse Bandit results
        if os.path.exists('bandit-raw.json'):
            try:
                with open('bandit-raw.json', 'r') as f:
                    bandit_data = json.load(f)
                    if 'results' in bandit_data:
                        for result in bandit_data['results'][:10]:
                            findings.append({
                                'tool': 'bandit',
                                'file': result.get('filename', 'unknown'),
                                'line': result.get('line_number', 0),
                                'severity': result.get('issue_severity', 'MEDIUM').lower(),
                                'rule': result.get('test_id', 'unknown'),
                                'message': result.get('issue_text', 'Security issue detected')
                            })
                        print(f"Found {len(findings) - len([f for f in findings if f['tool'] == 'semgrep'])} Bandit issues")
            except Exception as e:
                print(f"Error parsing Bandit: {e}")
        
        # Save aggregated results
        results = {
            'scanId': '{{inputs.scanId}}',
            'findings': findings,
            'summary': {
                'total': len(findings),
                'high': len([f for f in findings if f['severity'] == 'high']),
                'medium': len([f for f in findings if f['severity'] == 'medium']),
                'low': len([f for f in findings if f['severity'] == 'low'])
            }
        }
        
        with open('scan-results.json', 'w') as f:
            json.dump(results, f, indent=2)
        
        print(f"\nTotal findings: {len(findings)}")
        print(f"High: {results['summary']['high']}, Medium: {results['summary']['medium']}, Low: {results['summary']['low']}")
        PYTHON_SCRIPT
        
        echo ""
        echo "=== Scan Complete ==="
        
        # If issues found, create a branch with findings
        TOTAL=$(jq -r '.summary.total // 0' scan-results.json)
        if [ "$TOTAL" -gt 0 ]; then
          echo "Creating fix branch with findings..."
          cd repo
          
          # Create findings report
          cat > SECURITY_FINDINGS.md << 'MDEOF'
        # Security Scan Findings
        
        **Scan ID:** {{inputs.scanId}}
        **Date:** {{execution.startDate}}
        **Repository:** {{inputs.repoUrl}}
        **Branch:** {{inputs.branch}}
        
        ## Summary
        MDEOF
          
          # Add summary
          jq -r '.summary | "\n- Total Issues: \(.total)\n- High Severity: \(.high)\n- Medium Severity: \(.medium)\n- Low Severity: \(.low)\n"' ../scan-results.json >> SECURITY_FINDINGS.md
          
          echo "## Findings" >> SECURITY_FINDINGS.md
          echo "" >> SECURITY_FINDINGS.md
          
          # Add findings
          jq -r '.findings[] | "### \(.tool) - \(.severity | ascii_upcase)\n**File:** `\(.file)`  \n**Line:** \(.line)  \n**Rule:** \(.rule)  \n**Message:** \(.message)\n"' ../scan-results.json >> SECURITY_FINDINGS.md
          
          # Configure git
          git config user.email "security-bot@scanner.com"
          git config user.name "Security Scanner Bot"
          
          # Create branch
          BRANCH_NAME="security-scan-$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$BRANCH_NAME"
          
          # Commit findings
          git add SECURITY_FINDINGS.md
          git commit -m "üîí Security Scan Results - $TOTAL issues found

        Automated security scan completed.
        
        Summary:
        - Total Issues: $TOTAL
        - Scan ID: {{inputs.scanId}}
        - Tools: Semgrep, Bandit
        
        See SECURITY_FINDINGS.md for details."
          
          # Push branch
          git push -u origin "$BRANCH_NAME"
          
          echo "‚úÖ Branch created: $BRANCH_NAME"
          echo "$BRANCH_NAME" > ../branch-name.txt
          cd ..
        else
          echo "No issues found, skipping branch creation"
          echo "none" > branch-name.txt
        fi

  # Step 2: Create PR and Notify Backend
  - id: create_pr_and_notify
    type: io.kestra.plugin.scripts.shell.Commands
    description: Create pull request and notify backend
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: python:3.11-slim
    inputFiles:
      scan-results.json: "{{outputs.clone_scan_and_branch.outputFiles['scan-results.json']}}"
      branch-name.txt: "{{outputs.clone_scan_and_branch.outputFiles['branch-name.txt']}}"
      fork-owner.txt: "{{outputs.clone_scan_and_branch.outputFiles['fork-owner.txt']}}"
    commands:
      - |
        echo "=== Processing Results ==="
        
        apt-get update -qq && apt-get install -y -qq curl jq > /dev/null 2>&1
        
        TOTAL=$(jq -r '.summary.total // 0' scan-results.json)
        HIGH=$(jq -r '.summary.high // 0' scan-results.json)
        MEDIUM=$(jq -r '.summary.medium // 0' scan-results.json)
        LOW=$(jq -r '.summary.low // 0' scan-results.json)
        BRANCH_NAME=$(cat branch-name.txt)
        FORK_OWNER=$(cat fork-owner.txt)
        
        echo "Total Issues: $TOTAL"
        echo "Branch: $BRANCH_NAME"
        echo "Fork Owner: $FORK_OWNER"
        
        PR_URL="null"
        
        # Create PR if issues found
        if [ "$TOTAL" -gt 0 ] && [ "$BRANCH_NAME" != "none" ]; then
          echo ""
          echo "=== Creating Pull Request ==="
          
          REPO_URL="{{inputs.repoUrl}}"
          ORIGINAL_OWNER=$(echo "$REPO_URL" | sed 's|https://github.com/||' | cut -d/ -f1)
          REPO=$(echo "$REPO_URL" | sed 's|https://github.com/||' | cut -d/ -f2)
          
          # If forked, use fork_owner:branch format for head
          if [ "$FORK_OWNER" != "$ORIGINAL_OWNER" ]; then
            PR_HEAD="$FORK_OWNER:$BRANCH_NAME"
            echo "Creating PR from fork: $PR_HEAD -> $ORIGINAL_OWNER:{{inputs.branch}}"
          else
            PR_HEAD="$BRANCH_NAME"
            echo "Creating PR from same repo: $PR_HEAD -> {{inputs.branch}}"
          fi
          
          # Create PR body (properly escaped)
          PR_BODY="## Automated Security Scan

        **Scan ID:** {{inputs.scanId}}
        **Total Issues:** $TOTAL

        ### Summary
        - High: $HIGH
        - Medium: $MEDIUM  
        - Low: $LOW

        ### Details
        See \`SECURITY_FINDINGS.md\` for complete findings.

        ---
        *Automated by Security Scanner*"
                  
                  # Create JSON payload using jq to properly escape
                  PR_PAYLOAD=$(jq -n \
                    --arg title "üîí Security Scan Results - $TOTAL issues found" \
                    --arg body "$PR_BODY" \
                    --arg head "$PR_HEAD" \
                    --arg base "{{inputs.branch}}" \
                    '{title: $title, body: $body, head: $head, base: $base}')
                  
                  PR_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" -X POST "https://api.github.com/repos/$ORIGINAL_OWNER/$REPO/pulls" \
                    -H "Authorization: token {{secret('GITHUB_TOKEN')}}" \
                    -H "Accept: application/vnd.github.v3+json" \
                    -H "Content-Type: application/json" \
                    -d "$PR_PAYLOAD")
                  
                  # Extract HTTP code
                  HTTP_CODE=$(echo "$PR_RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
                  PR_BODY_RESPONSE=$(echo "$PR_RESPONSE" | sed '/HTTP_CODE:/d')
                  
                  # Try to parse URL, but don't fail if it has control characters
                  PR_URL=$(echo "$PR_BODY_RESPONSE" | jq -r '.html_url // empty' 2>/dev/null || echo "null")
                  
                  if [ "$HTTP_CODE" = "201" ]; then
                    # PR created successfully
                    if [ -z "$PR_URL" ] || [ "$PR_URL" = "null" ]; then
                      # Extract URL using grep as fallback
                      PR_URL=$(echo "$PR_BODY_RESPONSE" | grep -o '"html_url":"[^"]*"' | head -1 | cut -d'"' -f4)
                    fi
                  else
                    PR_URL="null"
                    PR_ERROR=$(echo "$PR_BODY_RESPONSE" | jq -r '.message // empty' 2>/dev/null || echo "Unknown error")
                  fi
                  
                  if [ "$PR_URL" != "null" ] && [ -n "$PR_URL" ]; then
                    echo "‚úÖ PR created: $PR_URL"
                  else
                    echo "‚ö†Ô∏è  PR creation failed"
                    if [ -n "$PR_ERROR" ]; then
                      echo "   Error: $PR_ERROR"
                    fi
                    echo "   Response: $PR_RESPONSE"
                  fi
                fi
                
                # Notify backend
                echo ""
                echo "=== Notifying Backend ==="
                BACKEND_URL="{{inputs.backendUrl}}"
                BACKEND_URL=$(echo "$BACKEND_URL" | sed 's/localhost/host.docker.internal/g')
                
                curl -X POST "$BACKEND_URL/api/webhooks/kestra" \
                  -H "Content-Type: application/json" \
                  -d "{
                    \"executionId\": \"{{execution.id}}\",
                    \"status\": \"success\",
                    \"scanId\": \"{{inputs.scanId}}\",
                    \"outputs\": {
                      \"issuesFound\": $TOTAL,
                      \"issuesFixed\": 0,
                      \"prUrl\": \"$PR_URL\",
                      \"summary\": {
                        \"high\": $HIGH,
                        \"medium\": $MEDIUM,
                        \"low\": $LOW
                      }
                    }
                  }" && echo "‚úÖ Backend notified" || echo "‚ö†Ô∏è  Notification failed"
                
                echo ""
                echo "=== Workflow Complete ==="
                echo "Scan ID: {{inputs.scanId}}"
                echo "Issues: $TOTAL"
                echo "PR: $PR_URL"

errors:
  - id: error_handler
    type: io.kestra.plugin.scripts.shell.Commands
    description: Handle workflow errors
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      image: curlimages/curl:latest
    commands:
      - |
        echo "Workflow failed, notifying backend..."
        BACKEND_URL="{{inputs.backendUrl}}"
        BACKEND_URL=$(echo "$BACKEND_URL" | sed 's/localhost/host.docker.internal/g')
        curl -X POST "$BACKEND_URL/api/webhooks/kestra" \
          -H "Content-Type: application/json" \
          -d "{
            \"executionId\": \"{{execution.id}}\",
            \"status\": \"failure\",
            \"scanId\": \"{{inputs.scanId}}\",
            \"error\": \"Workflow execution failed\"
          }" || echo "Failed to notify backend"

triggers:
  - id: webhook_trigger
    type: io.kestra.core.models.triggers.types.Webhook
    key: "security-scan-webhook-key"
    description: Webhook trigger for security scans
