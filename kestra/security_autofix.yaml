id: security_autofix
namespace: security

inputs:
  - id: repo_url
    type: STRING
    description: "GitHub repository URL"
  - id: base_branch
    type: STRING
    default: "main"
    description: "Base branch to scan"
  - id: max_iterations
    type: INTEGER
    default: 8
    description: "Maximum fix iterations"

tasks:
  - id: clone_repo
    type: io.kestra.plugin.git.Clone
    url: "{{ inputs.repo_url }}"
    branch: "{{ inputs.base_branch }}"

  - id: detect_languages
    type: io.kestra.plugin.scripts.python.Script
    script: |
      import os, json
      root = "{{ outputs.clone_repo.directory }}"
      exts = set()
      files = []
      for dirpath, _, filenames in os.walk(root):
        for f in filenames:
          path = os.path.join(dirpath, f)
          files.append(path)
          if '.' in f:
            exts.add(f.rsplit('.', 1)[1].lower())
      result = {
        "extensions": sorted(list(exts)),
        "file_count": len(files),
        "root": root
      }
      print(json.dumps(result))

  - id: initial_scan
    type: io.kestra.plugin.scripts.bash.Commands
    commands:
      - cd "{{ outputs.clone_repo.directory }}"
      - semgrep --config auto --json --output semgrep-result.json || true
      - bandit -r . -f json -o bandit-result.json || true
      - gitleaks detect --source . --report-format=json --report-path=gitleaks-result.json || true
      - "[ -f package.json ] && npx eslint -f json -o eslint-result.json . || true"

  - id: aggregate_issues
    type: io.kestra.plugin.scripts.python.Script
    script: |
      import json, os
      root = "{{ outputs.clone_repo.directory }}"
      
      def load_json(path):
        try:
          with open(path) as f:
            return json.load(f)
        except Exception:
          return {}
      
      sem = load_json(os.path.join(root, 'semgrep-result.json'))
      band = load_json(os.path.join(root, 'bandit-result.json'))
      gtl = load_json(os.path.join(root, 'gitleaks-result.json'))
      
      issues = {
        'semgrep': sem.get('results', []) if isinstance(sem, dict) else [],
        'bandit': band.get('results', []) if isinstance(band, dict) else [],
        'gitleaks': gtl if isinstance(gtl, list) else []
      }
      
      count = sum(len(v) for v in issues.values())
      print(json.dumps({'issues': issues, 'count': count}))
    outputFiles:
      - "*.json"

  - id: fix_loop
    type: io.kestra.plugin.core.flow.ForEach
    values: "{{ range(1, inputs.max_iterations + 1) }}"
    tasks:
      - id: check_remaining
        type: io.kestra.plugin.scripts.python.Script
        script: |
          import json, os
          root = "{{ outputs.clone_repo.directory }}"
          
          def load_json(name):
            try:
              with open(os.path.join(root, name)) as f:
                return json.load(f)
            except Exception:
              return {}
          
          sem = load_json('semgrep-result.json')
          band = load_json('bandit-result.json')
          gtl = load_json('gitleaks-result.json')
          
          count = 0
          if isinstance(sem, dict):
            count += len(sem.get('results', []))
          if isinstance(band, dict):
            count += len(band.get('results', []))
          if isinstance(gtl, list):
            count += len(gtl)
          
          print(json.dumps({'remaining': count, 'should_continue': count > 0}))

      - id: prepare_context
        type: io.kestra.plugin.scripts.python.Script
        runIf: "{{ outputs.check_remaining.vars.should_continue }}"
        script: |
          import json, os
          root = "{{ outputs.clone_repo.directory }}"
          
          def load_json(name):
            try:
              with open(os.path.join(root, name)) as f:
                return json.load(f)
            except Exception:
              return None
          
          sem = load_json('semgrep-result.json')
          band = load_json('bandit-result.json')
          gtl = load_json('gitleaks-result.json')
          
          def summarize_semgrep(s):
            if not isinstance(s, dict):
              return []
            return [
              {'path': r.get('path'), 'rule': r.get('check_id'), 'message': r.get('extra', {}).get('message', '')}
              for r in s.get('results', [])
            ][:15]
          
          def summarize_bandit(b):
            if not isinstance(b, dict):
              return []
            return [
              {'path': r.get('filename'), 'severity': r.get('issue_severity'), 'text': r.get('issue_text')}
              for r in b.get('results', [])
            ][:15]
          
          summary = {
            'semgrep': summarize_semgrep(sem),
            'bandit': summarize_bandit(band),
            'gitleaks_count': len(gtl) if isinstance(gtl, list) else 0,
            'repo_root': root
          }
          print(json.dumps(summary))

      - id: call_gemini
        type: io.kestra.plugin.http.Request
        runIf: "{{ outputs.check_remaining.vars.should_continue }}"
        uri: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={{ secret('GEMINI_API_KEY') }}"
        method: POST
        headers:
          Content-Type: "application/json"
        body: |
          {
            "contents": [{
              "parts": [{
                "text": "You are a security-aware code assistant. Analyze these security issues and provide fixes.\n\nIssues Summary:\n{{ outputs.prepare_context.vars | json }}\n\nTask: For each issue, produce a unified diff patch. Return JSON with: {\"patches\": [{\"path\": \"<relative-path>\", \"patch\": \"<unified-diff>\"}], \"explanations\": [{\"path\": \"<path>\", \"explanation\": \"<why>\"}]}. If unsafe, set patch to 'manual_review'."
              }]
            }],
            "generationConfig": {
              "maxOutputTokens": 2048,
              "temperature": 0.2
            }
          }
        contentType: application/json
        timeout: PT10M

      - id: apply_patches
        type: io.kestra.plugin.scripts.python.Script
        runIf: "{{ outputs.check_remaining.vars.should_continue }}"
        script: |
          import json, os, subprocess, re
          root = "{{ outputs.clone_repo.directory }}"
          
          response = '''{{ outputs.call_gemini.body }}'''
          
          # Extract JSON from response
          try:
            resp_data = json.loads(response)
            text = resp_data.get('candidates', [{}])[0].get('content', {}).get('parts', [{}])[0].get('text', '')
            
            # Find JSON in the text
            json_match = re.search(r'\{[\s\S]*\}', text)
            if json_match:
              data = json.loads(json_match.group())
            else:
              data = {}
          except Exception as e:
            print(json.dumps({'error': str(e), 'applied': []}))
            exit(0)
          
          patches = data.get('patches', [])
          applied = []
          
          for p in patches:
            if not isinstance(p, dict):
              continue
            path = p.get('path', '')
            patch_text = p.get('patch', '')
            
            if not patch_text or patch_text == 'manual_review':
              continue
            
            patch_file = os.path.join(root, 'temp_patch.diff')
            with open(patch_file, 'w') as pf:
              pf.write(patch_text)
            
            try:
              subprocess.run(['patch', '-p1', '-i', patch_file], cwd=root, check=True, capture_output=True)
              applied.append(path)
            except subprocess.CalledProcessError as e:
              print(f"Patch failed for {path}: {e.stderr.decode()}")
          
          print(json.dumps({'applied': applied, 'total': len(patches)}))

      - id: commit_iteration
        type: io.kestra.plugin.scripts.bash.Commands
        runIf: "{{ outputs.check_remaining.vars.should_continue }}"
        commands:
          - cd "{{ outputs.clone_repo.directory }}"
          - git add -A
          - git diff --cached --quiet || git commit -m "fix(security): automated fixes iteration {{ taskrun.value }}"

      - id: rescan
        type: io.kestra.plugin.scripts.bash.Commands
        runIf: "{{ outputs.check_remaining.vars.should_continue }}"
        commands:
          - cd "{{ outputs.clone_repo.directory }}"
          - semgrep --config auto --json --output semgrep-result.json || true
          - bandit -r . -f json -o bandit-result.json || true
          - gitleaks detect --source . --report-format=json --report-path=gitleaks-result.json || true

  - id: create_fix_branch
    type: io.kestra.plugin.scripts.bash.Commands
    commands:
      - cd "{{ outputs.clone_repo.directory }}"
      - BRANCH="ai-security-fixes-{{ execution.id }}"
      - git checkout -b "$BRANCH"
      - git push origin "$BRANCH"
      - echo "::output branch_name::$BRANCH"

  - id: create_pull_request
    type: io.kestra.plugin.http.Request
    uri: "https://api.github.com/repos/{{ inputs.repo_url | replace('https://github.com/', '') | replace('.git', '') }}/pulls"
    method: POST
    headers:
      Authorization: "Bearer {{ secret('GITHUB_TOKEN') }}"
      Accept: "application/vnd.github+json"
      X-GitHub-Api-Version: "2022-11-28"
    body: |
      {
        "title": "ðŸ”’ Automated Security Fixes",
        "head": "ai-security-fixes-{{ execution.id }}",
        "base": "{{ inputs.base_branch }}",
        "body": "## Automated Security Fixes\n\nThis PR contains security fixes generated by AI analysis.\n\n### Scanners Used\n- Semgrep\n- Bandit\n- Gitleaks\n\n**Please review all changes carefully before merging.**"
      }
    contentType: application/json

  - id: generate_report
    type: io.kestra.plugin.scripts.python.Script
    script: |
      import json, os
      root = "{{ outputs.clone_repo.directory }}"
      
      def load_json(name):
        try:
          with open(os.path.join(root, name)) as f:
            return json.load(f)
        except Exception:
          return None
      
      report = {
        'execution_id': '{{ execution.id }}',
        'repo_url': '{{ inputs.repo_url }}',
        'branch': '{{ inputs.base_branch }}',
        'final_scan': {
          'semgrep': load_json('semgrep-result.json'),
          'bandit': load_json('bandit-result.json'),
          'gitleaks': load_json('gitleaks-result.json')
        },
        'status': 'completed'
      }
      
      print(json.dumps(report))
